name: CI Release (Windows + macOS)

on:
  push:
    branches:
      - '**'

permissions:
  contents: write

concurrency:
  group: ci-release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build-macos:
    name: Build macOS (Universal)
    strategy:
      fail-fast: false
      matrix:
        os: [macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure (CMake)
        run: |
          cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DUniversalBinary=ON

      - name: Build (CMake)
        run: |
          cmake --build build --config Release -j$(sysctl -n hw.logicalcpu)

      - name: Ad-hoc codesign bundles
        run: |
          set -e
          BDIR="$(pwd)/build/SonoBus_artefacts/Release"
          for p in \
            "$BDIR/Standalone/SonoBus.app" \
            "$BDIR/VST3/SonoBus.vst3" \
            "$BDIR/AU/SonoBus.component" \
            "$BDIR/LV2/SonoBus.lv2" ; do
            if [ -e "$p" ]; then
              echo "Codesigning: $p"
              codesign -s - --deep --force "$p" || true
            fi
          done

      - name: Package macOS artifacts
        run: |
          set -e
          cd build/SonoBus_artefacts/Release
          # Prefer zipping specific types if present; otherwise zip all contents
          if [ -d Standalone ] || [ -d VST3 ] || [ -d AU ] || [ -d LV2 ]; then
            zip -r ../../SonoBus-macOS-universal.zip Standalone/*.app VST3/*.vst3 AU/*.component LV2/* 2>/dev/null || true
            # Fallback to everything under Release if patterns absent
            if [ ! -s ../../SonoBus-macOS-universal.zip ]; then
              zip -r ../../SonoBus-macOS-universal.zip .
            fi
          else
            zip -r ../../SonoBus-macOS-universal.zip .
          fi
          cd -

      - name: Upload macOS artifact
        uses: actions/upload-artifact@v4
        with:
          name: macos-universal
          path: build/SonoBus-macOS-universal.zip
          if-no-files-found: error

  build-windows:
    name: Build Windows (${{ matrix.arch }})
    runs-on: windows-latest
    env:
      ASIO_SDK_URL: ${{ secrets.ASIO_SDK_URL }}
      ASIO_BASE_URL: ${{ vars.ASIO_BASE_URL }}
    strategy:
      fail-fast: false
      matrix:
        arch: [x64, Win32]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fetch ASIO SDK (private URL)
        shell: pwsh
        run: |
          $url = $env:ASIO_SDK_URL
          if ([string]::IsNullOrWhiteSpace($url)) { Write-Host "No ASIO_SDK_URL provided; skipping zip fetch."; exit 0 }
          Write-Host "Downloading ASIO SDK from secret URL"
          Invoke-WebRequest -Uri $url -OutFile asiosdk.zip
          New-Item -ItemType Directory -Path asiosdk -Force | Out-Null
          Expand-Archive -Path asiosdk.zip -DestinationPath asiosdk -Force
          $sdkRoot = Join-Path (Resolve-Path ".").Path "asiosdk"
          $commonPath = Join-Path $sdkRoot "common"
          if (-not (Test-Path $commonPath)) {
            $candidate = Get-ChildItem -Recurse -Directory -Path $sdkRoot | Where-Object { Test-Path (Join-Path $_.FullName "common") } | Select-Object -First 1
            if ($candidate) { $sdkRoot = $candidate.FullName }
          }
          echo "ASIO_SDK_PATH=$sdkRoot" >> $env:GITHUB_ENV
          echo "ENABLE_ASIO=ON" >> $env:GITHUB_ENV

      - name: Fetch ASIO SDK headers (public base URL)
        # Use a simple base URL that serves individual headers, if provided.
        # Example: https://www.zedtiger.com/asio.sdk/
        shell: pwsh
        run: |
          if ($env:ENABLE_ASIO -eq "ON") { Write-Host "ASIO already enabled by zip; skipping base URL fetch."; exit 0 }
          $base = if ([string]::IsNullOrWhiteSpace($env:ASIO_BASE_URL)) { 'https://www.zedtiger.com/asio.sdk' } else { $env:ASIO_BASE_URL }
          Write-Host "Using ASIO base URL: $base"
          $sdkRoot = Join-Path (Resolve-Path ".").Path "asiosdk"
          $common = Join-Path $sdkRoot "common"
          New-Item -ItemType Directory -Force -Path $common | Out-Null
          $headers = @('asio.h','asiosys.h','asiodrivers.h','iasiodrv.h','iasiothiscallresolver.h')
          $downloaded = @{}
          foreach ($h in $headers) {
            $url = "$base/$h"
            $dest = Join-Path $common $h
            try {
              Invoke-WebRequest -Uri $url -OutFile $dest -UseBasicParsing -ErrorAction Stop
              Write-Host "Fetched $h"
              $downloaded[$h] = $true
            } catch {
              Write-Host "Could not fetch $h from $url"
            }
          }
          $essential = @('asio.h','asiosys.h','iasiodrv.h')
          $missing = @()
          foreach ($e in $essential) { if (-not $downloaded.ContainsKey($e)) { $missing += $e } }
          if ($missing.Count -eq 0) {
            echo "ASIO_SDK_PATH=$sdkRoot" >> $env:GITHUB_ENV
            echo "ENABLE_ASIO=ON" >> $env:GITHUB_ENV
            Write-Host "ASIO headers present; enabling ASIO."
          } else {
            echo "ENABLE_ASIO=OFF" >> $env:GITHUB_ENV
            Write-Host ("Missing essential headers: {0}; ASIO disabled" -f ($missing -join ', '))
          }

      - name: Configure (CMake)
        shell: pwsh
        run: |
          if ($env:ENABLE_ASIO -eq "ON" -and $env:ASIO_SDK_PATH) {
            cmake -S . -B build -G "Visual Studio 17 2022" -A ${{ matrix.arch }} -DCMAKE_BUILD_TYPE=Release -DSONOBUS_ENABLE_ASIO=ON -DASIO_SDK_PATH="$env:ASIO_SDK_PATH"
          } else {
            cmake -S . -B build -G "Visual Studio 17 2022" -A ${{ matrix.arch }} -DCMAKE_BUILD_TYPE=Release -DSONOBUS_ENABLE_ASIO=OFF
          }

      - name: Build (CMake)
        shell: pwsh
        run: |
          cmake --build build --config Release -j 4

      - name: Package Windows artifacts
        shell: pwsh
        run: |
          $releaseDir = Join-Path (Resolve-Path ".").Path "build/SonoBus_artefacts/Release"
          if (!(Test-Path $releaseDir)) { throw "Release directory not found: $releaseDir" }
          $zipName = "SonoBus-Windows-${{ matrix.arch }}.zip"
          if (Test-Path $zipName) { Remove-Item $zipName -Force }
          Compress-Archive -Path (Join-Path $releaseDir '*') -DestinationPath $zipName -Force
          echo "ZIP=$zipName" >> $env:GITHUB_ENV

      - name: Upload Windows artifact
        uses: actions/upload-artifact@v4
        with:
          name: windows-${{ matrix.arch }}
          path: ${{ env.ZIP }}
          if-no-files-found: error

  create-release:
    name: Create unified GitHub Release
    runs-on: ubuntu-latest
    needs: [build-macos, build-windows]
    if: ${{ always() }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Collect release payload
        id: collect
        run: |
          set -e
          mkdir -p release
          count=0
          while IFS= read -r -d '' f; do
            echo "Adding: $f"
            cp "$f" release/
            count=$((count+1))
          done < <(find artifacts -type f -name '*.zip' -print0)
          echo "Collected $count artifact(s)"
          if [ "$count" -gt 0 ]; then
            echo "have_files=true" >> "$GITHUB_OUTPUT"
          else
            echo "have_files=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create GitHub Release
        if: steps.collect.outputs.have_files == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: build-${{ github.sha }}
          name: SonoBus CI ${{ github.sha }}
          prerelease: true
          files: |
            release/*.zip
